// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

// gas 优化
contract gasLess {

    // 相同类型的放在一起
    uint128 a;
    uint128 b;
    uint256 c;

    // 全局存储状态变量 是storage存储的,不赋值默认减少gas消耗
    uint256 num;
    uint[] data;

    function cal(uint len) external{
        // 通过临时变量过度
        uint256 temp;
        for (uint i = 0; i < len; i++) {
            temp += 1; 
        }
        num = temp;
    }

    // 清理存储
    // 根据 EVM 的规则，在删除状态变量时，EVM 会返还一部分 gas，返还的 gas 可以用来抵消交易的消耗的 gas。尤其在清理大数据变量时，
    // 返还的 gas 将相当可观，最高可达交易消耗 Gas 的一半。
    function finishDelete() internal {
        delete data;
    }

    // 循环的时候尽量使数组的长度固定或者在一定范围内，不能太大

    // 初始化
    // 在 Solidity 中，每个变量的赋值都要消耗 Gas。在初始化变量时，避免使用默认值初始化，例如 uint256 value; 比 uint256 value = 0; 更便宜。

    // Require 字符串
    // 如果操作者在 require 中增加语句，可以通过限制字符串长度为 32 字节来降低 Gas 消耗。

    // 精确的声明函数可见性
    // 在 Solidity 合约开发中，显式声明函数的可见性不仅可以提高智能合约的安全性，同时也有利于优化合约执行的 gas 成本。例如，仅会通过外部执行的函数应该显式地标记函数为外部函数（External）而不是笼统的使用公共函数（public）。

    // 链下计算
    // 例如在排序列表中，向列表中添加元素后，依旧要确保其仍是排序的，经验不足的实现需要在整个集合中进行迭代，以找到合适的位置进行插入，一种更有效的方法是在链下计算合适的位置，仅在链上进行相应的验证(例如：添加的值时候位于其相邻元素之间)，这可以防止成本随数据结构的总大小线性增长。

    // 警惕循环
    // 当合约中存在依赖时间、依赖数据大小（如数组长度）的循环时，很多能导致潜在的漏洞。随数据量的增多（或时间的增长），gas 的消耗就可能对应的线性增长，很可能突破区块限制导致无法打包。

    // 首先要尽可能避免使用这种循环，将依靠循环的线性增长的计算量尽可能转化为固定的计算量大小（或常量）。如果没法做到转换，那就要考虑限制循环的次数，即限制总数据的大小，把一个大数据分拆为多个分段的小数据。(即想办法限制单次的计算量大小)，比如依靠时间长度计算收益的质押合约，可以采用设置质押有效期，比如设置质押有效期最长为一年，一年到期之后，用户需提取再质押。


}